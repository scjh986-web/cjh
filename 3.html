<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>极速太空射手（关卡版）</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #f5f7fa; 
            color: #1d1d1f; 
            font-family: HarmonyOS Sans SC, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            overflow-x: hidden;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            -webkit-user-select: none; 
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background-image: radial-gradient(circle at 50% 50%, rgba(250,252,255,0.9) 0%, rgba(242,245,250,1) 100%);
        }

        /* 游戏容器：保留原样式 */
        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            height: calc(100vh - 260px);
            border: 1px solid rgba(220,225,230,0.5); 
            border-radius: 18px; 
            background: rgba(255,255,255,0.85); 
            backdrop-filter: blur(16px); 
            -webkit-backdrop-filter: blur(16px);
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.04), 0 2px 8px rgba(0,0,0,0.02);
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            background-image: 
                linear-gradient(rgba(255,255,255,0.6), rgba(255,255,255,0.6)),
                radial-gradient(circle at 0% 0%, rgba(0,122,255,0.03) 0%, transparent 40%),
                radial-gradient(circle at 100% 100%, rgba(52,199,89,0.03) 0%, transparent 40%);
        }
        #star-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        .star {
            position: absolute;
            background: #fff;
            border-radius: 50%;
            animation: starTwinkle linear infinite;
        }
        @keyframes starTwinkle {
            0%,100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        #game-container:hover {
            box-shadow: 0 12px 40px rgba(0,0,0,0.06), 0 4px 12px rgba(0,0,0,0.03);
        }

        /* 玩家飞船：保留原样式 */
        #player {
            position: absolute;
            width: 42px;
            height: 42px;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50"><path fill="%23007AFF" d="M25 6L12 26h11l4 18 4-18h11L25 6zm0 14c-2.2 0-4 1.8-4 4s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4z"/></svg>') no-repeat center;
            background-size: contain;
            animation: float 2.8s ease-in-out infinite;
            z-index: 5;
            filter: drop-shadow(0 4px 12px rgba(0,122,255,0.15));
            transition: filter 0.3s ease, opacity 0.2s ease;
        }
        #player.hurt {
            filter: drop-shadow(0 4px 12px rgba(255,59,48,0.25));
            animation: hurtBlink 0.5s ease-in-out;
        }
        @keyframes hurtBlink {
            0%,100% { opacity: 1; }
            25% { opacity: 0.5; }
            50% { opacity: 1; }
            75% { opacity: 0.5; }
        }
        #player:active {
            filter: drop-shadow(0 2px 8px rgba(0,122,255,0.25));
        }
        @keyframes float {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-6px); }
        }
        #player.shield-active {
            box-shadow: 0 0 20px rgba(0,122,255,0.3), 0 0 8px rgba(0,122,255,0.5);
        }

        /* 子弹与敌人：保留原样式 */
        .bullet {
            position: absolute;
            width: 3px;
            height: 12px;
            background: #007AFF; 
            border-radius: 1.5px;
            bottom: 68px;
            box-shadow: 0 0 10px rgba(0,122,255,0.3), 0 0 2px rgba(0,122,255,0.5);
            z-index: 4;
        }
        .enemy {
            position: absolute;
            width: 36px;
            height: 36px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            animation: enemyFloat 3.2s ease-in-out infinite;
            filter: drop-shadow(0 4px 12px rgba(255,59,48,0.12));
            transition: filter 0.3s ease;
            z-index: 3;
            --hp: 1;
        }
        .enemy.normal {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><path fill="%23FF3B30" d="M20 9C12.8 9 6 15.8 6 23s6.8 14 14 14 14-6.8 14-14S27.2 9 20 9zm0 24c-5.5 0-10-4.5-10-10s4.5-10 10-10 10 4.5 10 10-4.5 10-10 10z"/></svg>');
        }
        .enemy.strong {
            width: 42px;
            height: 42px;
            --hp: 2;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 40 40"><path fill="%23FF9500" d="M20 8C11.8 8 5 14.8 5 23s6.8 15 15 15 15-6.8 15-15S28.2 8 20 8zm0 26c-6.1 0-11-4.9-11-11s4.9-11 11-11 11 4.9 11 11-4.9 11-11 11z"/><path fill="%23FFF" d="M17 18h6v6h-6z"/></svg>');
            filter: drop-shadow(0 4px 12px rgba(255,149,0,0.18));
        }
        .enemy.boss {
            width: 56px;
            height: 56px;
            --hp: 8;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50"><path fill="%23AF52DE" d="M25 10C14.5 10 6 18.5 6 29s8.5 19 19 19 19-8.5 19-19S35.5 10 25 10zm0 32c-4.9 0-9-4.1-9-9s4.1-9 9-9 9 4.1 9 9-4.1 9-9 9z"/><path fill="%23FFF" d="M21 22h2v6h-2zm6 0h2v6h-2z"/></svg>');
            filter: drop-shadow(0 6px 16px rgba(175,82,222,0.25));
            animation: bossFloat 4s ease-in-out infinite;
        }
        .enemy.boss-bullet {
            width: 8px;
            height: 16px;
            background: #AF52DE;
            border-radius: 4px;
            box-shadow: 0 0 8px rgba(175,82,222,0.5);
            animation: none;
            --hp: 1;
        }
        @keyframes bossFloat {
            0%,100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-10px) rotate(2deg); }
        }
        .enemy:hover {
            filter: drop-shadow(0 4px 12px rgba(255,59,48,0.18));
        }
        @keyframes enemyFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(8px); }
        }
        .enemy-hp {
            position: absolute;
            bottom: -8px;
            left: 10%;
            width: 80%;
            height: 3px;
            background: rgba(0,0,0,0.1);
            border-radius: 1.5px;
            overflow: hidden;
        }
        .enemy-hp-fill {
            height: 100%;
            background: #FF3B30;
            transition: width 0.2s ease;
        }
        .enemy.strong .enemy-hp-fill { background: #FF9500; }
        .enemy.boss .enemy-hp-fill { background: #AF52DE; height: 4px; }

        /* 爆炸特效：保留原样式 */
        .explosion {
            position: absolute;
            border-radius: 50%;
            box-shadow: 0 0 24px rgba(255,107,107,0.35), 0 0 8px rgba(255,107,107,0.5);
            animation: explode 0.6s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
            z-index: 10;
        }
        .explosion.normal {
            width: 44px;
            height: 44px;
            background: radial-gradient(circle, #FFCC00 0%, #FF9500 50%, #FF6B6B 100%);
        }
        .explosion.strong {
            width: 56px;
            height: 56px;
            background: radial-gradient(circle, #FFE066 0%, #FFB74D 50%, #FF8A65 100%);
            box-shadow: 0 0 32px rgba(255,183,77,0.4), 0 0 12px rgba(255,183,77,0.6);
        }
        .explosion.boss {
            width: 80px;
            height: 80px;
            background: radial-gradient(circle, #FFD54F 0%, #FFAB91 50%, #EA80FC 100%);
            box-shadow: 0 0 48px rgba(234,128,252,0.5), 0 0 16px rgba(234,128,252,0.7);
            animation: bossExplode 0.8s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
        }
        @keyframes bossExplode {
            0% { transform: scale(0.6); opacity: 1; }
            70% { transform: scale(2.8); opacity: 0.8; }
            100% { transform: scale(3.2); opacity: 0; }
        }
        @keyframes explode {
            0% { transform: scale(0.6); opacity: 1; }
            100% { transform: scale(2.2); opacity: 0; }
        }

        /* 道具系统：保留原样式 */
        .powerup {
            position: absolute;
            width: 32px;
            height: 32px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 4;
            animation: powerupFloat 3s ease-in-out infinite;
            filter: drop-shadow(0 4px 8px rgba(52,199,89,0.2));
        }
        @keyframes powerupFloat {
            0%,100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-8px) rotate(5deg); }
        }
        .powerup.double-shot {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path fill="%2334C759" d="M16 4C9.3 4 4 9.3 4 16s5.3 12 12 12 12-5.3 12-12S22.7 4 16 4zm0 20c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8z"/><path fill="%23FFF" d="M12 14h4v8h-4zm6-4h4v12h-4z"/></svg>');
        }
        .powerup.shield {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path fill="%23007AFF" d="M16 6c-3.8 0-7.2 2.1-9.1 5.2L2 16l4.9 4.8C8.8 23.9 12.226 16 26s7.2-2.1 9.1-5.2L30 16l-4.9-4.8C23.2 8.1 19.8 6 16 6zm0 16c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4z"/></svg>');
        }

        /* 游戏UI：保留原样式 */
        .game-ui {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            margin-bottom: 8px;
        }
        .ui-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 16px;
            font-weight: 500;
            color: #1d1d1f;
        }
        .ui-item .icon {
            width: 22px;
            height: 22px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        .ui-item.level .icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%231d1d1f" d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/></svg>');
        }
        .ui-item.score .icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%231d1d1f" d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 14h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>');
        }
        .ui-item.lives .icon {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="%23FF3B30" d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>');
        }

        /* 按钮样式：保留原双选界面样式 */
        .game-buttons {
            width: 100%;
            max-width: 600px;
            display: flex;
            gap: 12px;
            margin-top: 16px;
        }
        .game-btn {
            flex: 1;
            padding: 12px 0;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 500;
            color: #fff;
            background: #007AFF;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,122,255,0.15);
        }
        .game-btn:hover {
            background: #0066CC;
            box-shadow: 0 6px 16px rgba(0,122,255,0.2);
            transform: translateY(-1px);
        }
        .game-btn:active {
            transform: translateY(1px);
            box-shadow: 0 2px 8px rgba(0,122,255,0.15);
        }
        .game-btn.reset {
            background: #FF3B30;
            box-shadow: 0 4px 12px rgba(255,59,48,0.15);
        }
        .game-btn.reset:hover {
            background: #CC2E25;
            box-shadow: 0 6px 16px rgba(255,59,48,0.2);
        }

        /* 弹窗样式：保留原样式 */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .modal.active {
            opacity: 1;
            pointer-events: auto;
        }
        .modal-content {
            background: #fff;
            border-radius: 18px;
            padding: 24px;
            width: 90%;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }
        .modal.active .modal-content {
            transform: translateY(0);
        }
        .modal-title {
            font-size: 22px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 12px;
        }
        .modal-text {
            font-size: 16px;
            color: #6e6e73;
            margin-bottom: 24px;
        }
        .modal-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 500;
            color: #fff;
            background: #007AFF;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .modal-btn:hover {
            background: #0066CC;
        }
    </style>
</head>
<body>
    <!-- 游戏UI：保留原结构 -->
    <div class="game-ui">
        <div class="ui-item level">
            <div class="icon"></div>
            <span id="level-display">关卡: 1</span>
        </div>
        <div class="ui-item score">
            <div class="icon"></div>
            <span id="score-display">分数: 0</span>
        </div>
        <div class="ui-item lives">
            <div class="icon"></div>
            <span id="lives-display">剩余: 3</span>
        </div>
    </div>

    <!-- 游戏容器：保留原结构 -->
    <div id="game-container">
        <div id="star-bg"></div>
        <div id="player"></div>
    </div>

    <!-- 双选按钮界面：完全保留原样式结构 -->
    <div class="game-buttons">
        <button class="game-btn" id="start-btn">开始游戏</button>
        <button class="game-btn reset" id="reset-btn">重置游戏</button>
    </div>

    <!-- 游戏结束弹窗：保留原结构 -->
    <div class="modal" id="game-over-modal">
        <div class="modal-content">
            <h2 class="modal-title">游戏结束</h2>
            <p class="modal-text" id="game-over-text">最终分数: 0</p>
            <button class="modal-btn" id="restart-btn">重新开始</button>
        </div>
    </div>

    <script>
        // 游戏核心变量：保留原逻辑
        const game = {
            isRunning: false,
            level: 1,
            score: 0,
            lives: 3,
            playerSpeed: 5,
            bulletSpeed: 8,
            enemySpeed: 2,
            bossBulletSpeed: 4,
            enemySpawnRate: 1500,
            enemySpawnTimer: null,
            bossSpawnLevel: 3,
            isBossActive: false,
            bossHp: 8,
            powerupSpawnRate: 8000,
            powerupSpawnTimer: null,
            activePowerups: {},
            doubleShotDuration: 10000,
            shieldDuration: 12000
        };

        // DOM元素：保留原获取逻辑
        const player = document.getElementById('player');
        const gameContainer = document.getElementById('game-container');
        const starBg = document.getElementById('star-bg');
        const levelDisplay = document.getElementById('level-display');
        const scoreDisplay = document.getElementById('score-display');
        const livesDisplay = document.getElementById('lives-display');
        const startBtn = document.getElementById('start-btn');
        const resetBtn = document.getElementById('reset-btn');
        const gameOverModal = document.getElementById('game-over-modal');
        const gameOverText = document.getElementById('game-over-text');
        const restartBtn = document.getElementById('restart-btn');

        // 初始化星空背景：保留原逻辑
        function initStars() {
            starBg.innerHTML = '';
            const starCount = 50;
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.classList.add('star');
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.width = `${Math.random() * 2 + 1}px`;
                star.style.height = star.style.width;
                star.style.animationDuration = `${Math.random() * 3 + 2}s`;
                star.style.animationDelay = `${Math.random() * 5}s`;
                starBg.appendChild(star);
            }
        }

        // 初始化游戏：保留原逻辑
        function initGame() {
            game.isRunning = false;
            game.level = 1;
            game.score = 0;
            game.lives = 3;
            game.isBossActive = false;
            game.bossHp = 8;
            game.activePowerups = {};
            
            updateGameUI();
            resetPlayerPosition();
            clearAllElements();
            initStars();
            gameOverModal.classList.remove('active');
        }

        // 重置玩家位置：保留原逻辑
        function resetPlayerPosition() {
            const containerWidth = gameContainer.offsetWidth;
            player.style.left = `${containerWidth / 2 - player.offsetWidth / 2}px`;
            player.style.bottom = '24px';
            player.classList.remove('shield-active');
        }

        // 清除所有元素：保留原逻辑
        function clearAllElements() {
            document.querySelectorAll('.bullet, .enemy, .explosion, .powerup').forEach(el => el.remove());
            if (game.enemySpawnTimer) clearInterval(game.enemySpawnTimer);
            if (game.powerupSpawnTimer) clearInterval(game.powerupSpawnTimer);
        }

        // 更新游戏UI：保留原逻辑
        function updateGameUI() {
            levelDisplay.textContent = `关卡: ${game.level}`;
            scoreDisplay.textContent = `分数: ${game.score}`;
            livesDisplay.textContent = `剩余: ${game.lives}`;
        }

        // 开始游戏：保留原逻辑
        function startGame() {
            if (game.isRunning) return;
            
            game.isRunning = true;
            startBtn.disabled = true;
            startBtn.textContent = '游戏中';
            
            startEnemySpawn();
            startPowerupSpawn();
            initControls();
        }

        // 重置游戏：保留原逻辑
        function resetGame() {
            initGame();
            startBtn.disabled = false;
            startBtn.textContent = '开始游戏';
        }

        // 初始化控制：保留原逻辑
        function initControls() {
            let isDragging = false;
            let touchX = 0;
            let mouseX = 0;
            const containerWidth = gameContainer.offsetWidth;
            const playerWidth = player.offsetWidth;

            // 触摸控制
            gameContainer.addEventListener('touchstart', (e) => {
                if (!game.isRunning) return;
                isDragging = true;
                touchX = e.touches[0].clientX;
            });

            gameContainer.addEventListener('touchmove', (e) => {
                if (!game.isRunning || !isDragging) return;
                const deltaX = e.touches[0].clientX - touchX;
                touchX = e.touches[0].clientX;
                
                let newLeft = parseInt(player.style.left) + deltaX;
                newLeft = Math.max(0, Math.min(newLeft, containerWidth - playerWidth));
                player.style.left = `${newLeft}px`;
            });

            gameContainer.addEventListener('touchend', () => {
                isDragging = false;
            });

            // 鼠标控制
            gameContainer.addEventListener('mousedown', (e) => {
                if (!game.isRunning) return;
                isDragging = true;
                mouseX = e.clientX;
            });

            gameContainer.addEventListener('mousemove', (e) => {
                if (!game.isRunning || !isDragging) return;
                const deltaX = e.clientX - mouseX;
                mouseX = e.clientX;
                
                let newLeft = parseInt(player.style.left) + deltaX;
                newLeft = Math.max(0, Math.min(newLeft, containerWidth - playerWidth));
                player.style.left = `${newLeft}px`;
            });

            gameContainer.addEventListener('mouseup', () => {
                isDragging = false;
            });

            gameContainer.addEventListener('mouseleave', () => {
                isDragging = false;
            });

            // 自动射击：保留原逻辑
            const shootInterval = setInterval(() => {
                if (!game.isRunning) {
                    clearInterval(shootInterval);
                    return;
                }
                shootBullet();
            }, 500);
        }

        // 发射子弹：【核心修复】修正子弹初始top值计算，确保向上运动
        function shootBullet() {
            const playerLeft = parseInt(player.style.left);
            // 修复：通过offsetTop获取玩家顶部位置，而非未定义的playerTop
            const playerTop = player.offsetTop; 
            const playerWidth = player.offsetWidth;
            const bulletHeight = 12;

            // 基础单发：使用正确的playerTop计算子弹初始位置
            createBullet(playerLeft + playerWidth / 2 - 1.5, playerTop - bulletHeight);

            // 双发道具逻辑：保留原逻辑
            if (game.activePowerups.doubleShot) {
                createBullet(playerLeft + playerWidth / 2 + 8, playerTop - bulletHeight);
                createBullet(playerLeft + playerWidth / 2 - 11, playerTop - bulletHeight);
            }
        }

        // 创建子弹：【核心修复】确保子弹移动逻辑正常执行
        function createBullet(x, y) {
            const bullet = document.createElement('div');
            bullet.classList.add('bullet');
            // 修复：明确设置子弹left和top（原代码可能存在top值未完整赋值问题）
            bullet.style.left = `${x}px`;
            bullet.style.top = `${y}px`;
            gameContainer.appendChild(bullet);

            // 子弹移动逻辑：保留原逻辑，确保间隔执行
            const bulletMoveInterval = setInterval(() => {
                // 检测子弹是否存在，避免空引用
                if (!game.isRunning || !bullet.parentNode) {
                    clearInterval(bulletMoveInterval);return;
                }

                // 正确获取并更新子弹top值，实现向上运动
                let currentTop = parseInt(bullet.style.top);
                // 子弹超出屏幕顶部时移除，避免内存占用
                if (currentTop < -bullet.offsetHeight) {
                    bullet.remove();
                    clearInterval(bulletMoveInterval);
                    return;
                }

                // 向上移动：top值减少（屏幕坐标系top从0开始向上递增）
                bullet.style.top = `${currentTop - game.bulletSpeed}px`;

                // 检测子弹与敌人碰撞
                checkBulletEnemyCollision(bullet, bulletMoveInterval);
            }, 20); // 20ms间隔确保移动流畅
        }

        // 检测子弹与敌人碰撞：保留原逻辑
        function checkBulletEnemyCollision(bullet, interval) {
            const bulletRect = bullet.getBoundingClientRect();
            const enemies = document.querySelectorAll('.enemy:not(.boss-bullet)');

            enemies.forEach(enemy => {
                const enemyRect = enemy.getBoundingClientRect();
                if (isCollide(bulletRect, enemyRect)) {
                    bullet.remove();
                    clearInterval(interval);

                    const enemyHp = parseInt(enemy.dataset.hp) || 1;
                    const newHp = enemyHp - 1;
                    enemy.dataset.hp = newHp;

                    const hpFill = enemy.querySelector('.enemy-hp-fill');
                    if (hpFill) {
                        const maxHp = parseInt(enemy.dataset.maxHp) || 1;
                        hpFill.style.width = `${(newHp / maxHp) * 100}%`;
                    }

                    if (newHp <= 0) {
                        const enemyType = enemy.classList.contains('strong') ? 'strong' : 
                                          enemy.classList.contains('boss') ? 'boss' : 'normal';
                        createExplosion(
                            enemyRect.left + enemyRect.width/2 - gameContainer.getBoundingClientRect().left,
                            enemyRect.top + enemyRect.height/2 - gameContainer.getBoundingClientRect().top,
                            enemyType
                        );

                        const scoreAdd = enemyType === 'normal' ? 10 : 
                                        enemyType === 'strong' ? 25 : 100;
                        game.score += scoreAdd;
                        updateGameUI();

                        enemy.remove();

                        if (enemyType === 'boss') {
                            game.isBossActive = false;
                            setTimeout(() => {
                                game.level++;
                                updateGameUI();
                                increaseDifficulty();
                                startEnemySpawn(true);
                            }, 1500);
                        }
                    }
                }
            });
        }

        // 开始生成敌人：保留原逻辑
        function startEnemySpawn(forceReset = false) {
            if (game.enemySpawnTimer) clearInterval(game.enemySpawnTimer);
            if (game.isBossActive) return;

            game.enemySpawnTimer = setInterval(() => {
                if (!game.isRunning) {
                    clearInterval(game.enemySpawnTimer);
                    return;
                }

                const level = game.level;
                const strongChance = Math.min(0.1 * level, 0.5);
                const isStrong = Math.random() < strongChance;

                const currentEnemyCount = document.querySelectorAll('.enemy:not(.boss-bullet)').length;
                if (currentEnemyCount < 5) {
                    createEnemy(isStrong ? 'strong' : 'normal');
                }

                if (level % game.bossSpawnLevel === 0 && !game.isBossActive) {
                    createEnemy('boss');
                    game.isBossActive = true;
                    clearInterval(game.enemySpawnTimer);
                }
            }, game.enemySpawnRate);
        }

        // 创建敌人：保留原逻辑
        function createEnemy(type = 'normal') {
            const containerWidth = gameContainer.offsetWidth;
            const enemy = document.createElement('div');
            enemy.classList.add('enemy', type);
            
            const maxHp = type === 'normal' ? 1 : type === 'strong' ? 2 : 8;
            enemy.dataset.maxHp = maxHp;
            enemy.dataset.hp = maxHp;

            const enemyWidth = enemy.offsetWidth || (type === 'boss' ? 56 : type === 'strong' ? 42 : 36);
            const minX = 10;
            const maxX = containerWidth - enemyWidth - 10;
            const randomX = Math.floor(Math.random() * (maxX - minX + 1)) + minX;
            
            enemy.style.left = `${randomX}px`;
            enemy.style.top = `${-enemy.offsetHeight || -36}px`;

            if (type === 'strong' || type === 'boss') {
                const hpContainer = document.createElement('div');
                hpContainer.classList.add('enemy-hp');
                const hpFill = document.createElement('div');
                hpFill.classList.add('enemy-hp-fill');
                hpFill.style.width = '100%';
                hpContainer.appendChild(hpFill);
                enemy.appendChild(hpContainer);
            }

            gameContainer.appendChild(enemy);

            if (type === 'boss') {
                setTimeout(() => {
                    bossShoot(enemy);
                }, 1000);
            }

            const enemyMoveInterval = setInterval(() => {
                if (!game.isRunning || !enemy.parentNode) {
                    clearInterval(enemyMoveInterval);
                    return;
                }

                let currentTop = parseInt(enemy.style.top) || 0;
                const containerHeight = gameContainer.offsetHeight;
                const enemyHeight = enemy.offsetHeight || 36;

                if (currentTop > containerHeight) {
                    enemy.remove();
                    clearInterval(enemyMoveInterval);
                    playerTakeDamage();
                    return;
                }

                const moveSpeed = type === 'boss' ? game.enemySpeed * 0.5 : game.enemySpeed;
                enemy.style.top = `${currentTop + moveSpeed}px`;

                checkEnemyPlayerCollision(enemy, enemyMoveInterval);
            }, 30);
        }

        // BOSS发射子弹：保留原逻辑
        function bossShoot(boss) {
            if (!game.isRunning || !boss.parentNode || !game.isBossActive) return;

            const bossRect = boss.getBoundingClientRect();
            const containerRect = gameContainer.getBoundingClientRect();

            const bulletPositions = [
                bossRect.left + bossRect.width/4 - containerRect.left,
                bossRect.left + 3*bossRect.width/4 - containerRect.left
            ];

            bulletPositions.forEach(x => {
                const bullet = document.createElement('div');
                bullet.classList.add('enemy', 'boss-bullet');
                bullet.style.left = `${x}px`;
                bullet.style.top = `${bossRect.bottom - containerRect.top}px`;
                bullet.dataset.hp = 1;
                gameContainer.appendChild(bullet);

                const bulletInterval = setInterval(() => {
                    if (!game.isRunning || !bullet.parentNode) {
                        clearInterval(bulletInterval);
                        return;
                    }

                    let currentTop = parseInt(bullet.style.top);
                    const containerHeight = gameContainer.offsetHeight;

                    if (currentTop > containerHeight) {
                        bullet.remove();
                        clearInterval(bulletInterval);
                        return;
                    }

                    bullet.style.top = `${currentTop + game.bossBulletSpeed}px`;

                    checkBossBulletPlayerCollision(bullet, bulletInterval);
                    checkPlayerBulletBossBulletCollision(bullet, bulletInterval);
                }, 20);
            });

            if (game.isRunning && game.isBossActive) {
                setTimeout(() => bossShoot(boss), 2000);
            }
        }

        // 检测BOSS子弹与玩家碰撞：保留原逻辑
        function checkBossBulletPlayerCollision(bullet, interval) {
            if (!player.parentNode) return;

            const bulletRect = bullet.getBoundingClientRect();
            const playerRect = player.getBoundingClientRect();

            if (isCollide(bulletRect, playerRect)) {
                if (game.activePowerups.shield) {
                    createExplosion(
                        bulletRect.left + bulletRect.width/2 - gameContainer.getBoundingClientRect().left,
                        bulletRect.top + bulletRect.height/2 - gameContainer.getBoundingClientRect().top,
                        'normal'
                    );
                    bullet.remove();
                    clearInterval(interval);
                    return;
                }

                player.classList.add('hurt');
                setTimeout(() => player.classList.remove('hurt'), 500);

                game.lives--;
                updateGameUI();

                bullet.remove();
                clearInterval(interval);

                if (game.lives <= 0) {
                    endGame();
                }
            }
        }

        // 检测玩家子弹与BOSS子弹碰撞：保留原逻辑
        function checkPlayerBulletBossBulletCollision(bossBullet, bossBulletInterval) {
            const bossBulletRect = bossBullet.getBoundingClientRect();
            const playerBullets = document.querySelectorAll('.bullet');

            playerBullets.forEach(playerBullet => {
                const playerBulletRect = playerBullet.getBoundingClientRect();
                if (isCollide(bossBulletRect, playerBulletRect)) {
                    createExplosion(
                        bossBulletRect.left + bossBulletRect.width/2 - gameContainer.getBoundingClientRect().left,
                        bossBulletRect.top + bossBulletRect.height/2 - gameContainer.getBoundingClientRect().top,
                        'normal'
                    );

                    bossBullet.remove();
                    playerBullet.remove();
                    clearInterval(bossBulletInterval);
                }
            });
        }

        // 检测敌人与玩家碰撞：保留原逻辑
        function checkEnemyPlayerCollision(enemy, enemyInterval) {
            if (!player.parentNode || enemy.classList.contains('boss-bullet')) return;

            const enemyRect = enemy.getBoundingClientRect();
            const playerRect = player.getBoundingClientRect();

            if (isCollide(enemyRect, playerRect)) {
                if (game.activePowerups.shield) {
                    createExplosion(
                        enemyRect.left + enemyRect.width/2 - gameContainer.getBoundingClientRect().left,
                        enemyRect.top + enemyRect.height/2 - gameContainer.getBoundingClientRect().top,
                        enemy.classList.contains('strong') ? 'strong' : 'normal'
                    );
                    enemy.remove();
                    clearInterval(enemyInterval);
                    return;
                }

                player.classList.add('hurt');
                setTimeout(() => player.classList.remove('hurt'), 500);

                game.lives--;
                updateGameUI();

                createExplosion(
                    enemyRect.left + enemyRect.width/2 - gameContainer.getBoundingClientRect().left,
                    enemyRect.top + enemyRect.height/2 - gameContainer.getBoundingClientRect().top,
                    enemy.classList.contains('strong') ? 'strong' : 'normal'
                );

                enemy.remove();
                clearInterval(enemyInterval);

                if (game.lives <= 0) {
                    endGame();
                }
            }
        }

        // 创建爆炸效果：保留原逻辑
        function createExplosion(x, y, type = 'normal') {
            const explosion = document.createElement('div');
            explosion.classList.add('explosion', type);
            
            const explosionSize = explosion.offsetWidth || (type === 'boss' ? 80 : type === 'strong' ? 56 : 44);
            explosion.style.left = `${x - explosionSize/2}px`;
            explosion.style.top = `${y - explosionSize/2}px`;
            
            gameContainer.appendChild(explosion);

            setTimeout(() => {
                if (explosion.parentNode) explosion.remove();
            }, type === 'boss' ? 800 : 600);
        }

        // 开始生成道具：保留原逻辑
        function startPowerupSpawn() {
            if (game.powerupSpawnTimer) clearInterval(game.powerupSpawnTimer);

            game.powerupSpawnTimer = setInterval(() => {
                if (!game.isRunning) {
                    clearInterval(game.powerupSpawnTimer);
                    return;
                }

                const powerupType = Math.random() > 0.5 ? 'double-shot' : 'shield';
                createPowerup(powerupType);
            }, game.powerupSpawnRate);
        }

        // 创建道具：保留原逻辑
        function createPowerup(type = 'double-shot') {
            const containerWidth = gameContainer.offsetWidth;
            const powerup = document.createElement('div');
            powerup.classList.add('powerup', type);
            
            const powerupWidth = 32;
            const minX = 10;
            const maxX = containerWidth - powerupWidth - 10;
            const randomX = Math.floor(Math.random() * (maxX - minX + 1)) + minX;
            
            powerup.style.left = `${randomX}px`;
            powerup.style.top = `${-powerupWidth}px`;

            gameContainer.appendChild(powerup);

            const powerupInterval = setInterval(() => {
                if (!game.isRunning || !powerup.parentNode) {
                    clearInterval(powerupInterval);
                    return;
                }

                let currentTop = parseInt(powerup.style.top);
                const containerHeight = gameContainer.offsetHeight;

                if (currentTop > containerHeight) {
                    powerup.remove();
                    clearInterval(powerupInterval);
                    return;
                }

                powerup.style.top = `${currentTop + game.enemySpeed * 0.7}px`;

                checkPowerupPlayerCollision(powerup, powerupInterval);
            }, 30);
        }

        // 检测道具与玩家碰撞：保留原逻辑
        function checkPowerupPlayerCollision(powerup, interval) {
            if (!player.parentNode) return;

            const powerupRect = powerup.getBoundingClientRect();
            const playerRect = player.getBoundingClientRect();

            if (isCollide(powerupRect, playerRect)) {
                const powerupType = powerup.classList.contains('double-shot') ? 'double-shot' : 'shield';
                activatePowerup(powerupType);

                powerup.remove();
                clearInterval(interval);

                createExplosion(
                    powerupRect.left + powerupRect.width/2 - gameContainer.getBoundingClientRect().left,
                    powerupRect.top + powerupRect.height/2 - gameContainer.getBoundingClientRect().top,
                    'normal'
                );
            }
        }

        // 激活道具效果：保留原逻辑
        function activatePowerup(type) {
            if (game.activePowerups[type]?.timer) {
                clearTimeout(game.activePowerups[type].timer);
            }

            if (type === 'double-shot') {
                game.activePowerups.doubleShot = {
                    active: true,
                    timer: setTimeout(() => {
                        game.activePowerups.doubleShot.active = false;
                        delete game.activePowerups.doubleShot;
                    }, game.doubleShotDuration)
                };
            }

            if (type === 'shield') {
                game.activePowerups.shield = {
                    active: true,
                    timer: setTimeout(() => {
                        game.activePowerups.shield.active = false;
                        delete game.activePowerups.shield;
                        player.classList.remove('shield-active');
                    }, game.shieldDuration)
                };
                player.classList.add('shield-active');
            }
        }

        // 玩家受到伤害：保留原逻辑
        function playerTakeDamage() {
            player.classList.add('hurt');
            setTimeout(() => player.classList.remove('hurt'), 500);
            
            game.lives--;
            updateGameUI();
            
            if (game.lives <= 0) {
                endGame();
            }
        }

        // 增加游戏难度：保留原逻辑
        function increaseDifficulty() {
            game.enemySpeed = Math.min(2 + (game.level - 1) * 0.2, 4);
            game.bossBulletSpeed = Math.min(4 + (game.level - 1) * 0.15, 6);
            game.enemySpawnRate = Math.max(1500 - (game.level - 1) * 100, 800);
            game.powerupSpawnRate = Math.max(8000 - (game.level - 1) * 500, 5000);
        }

        // 结束游戏：保留原逻辑
        function endGame() {
            game.isRunning = false;
            startBtn.disabled = false;
            startBtn.textContent = '开始游戏';
            
            if (game.enemySpawnTimer) clearInterval(game.enemySpawnTimer);
            if (game.powerupSpawnTimer) clearInterval(game.powerupSpawnTimer);
            
            gameOverText.textContent = `最终分数: ${game.score} | 最终关卡: ${game.level}`;
            gameOverModal.classList.add('active');
        }

        // 碰撞检测工具函数：保留原逻辑
        function isCollide(rect1, rect2) {
            return rect1.left < rect2.right &&
                   rect1.right > rect2.left &&
                   rect1.top < rect2.bottom &&
                   rect1.bottom > rect2.top;
        }

        // 事件监听：保留原逻辑
        startBtn.addEventListener('click', startGame);
        resetBtn.addEventListener('click', resetGame);
        restartBtn.addEventListener('click', resetGame);

        window.addEventListener('resize', () => {
            if (player.parentNode) {
                resetPlayerPosition();
            }
        });

        // 页面加载初始化：保留原逻辑
        window.addEventListener('load', initGame);
    </script>
</body>
</html>